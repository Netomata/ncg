.TH NETO 5 "" "" "Netomata, Inc."
.SH NAME
neto \- Netomata network description
.
.SH DESCRIPTION
Netomata network description files (which are commonly named with
the extension
.BR .neto )
are used as input by Netomata tools such as
.BR ncg (1),
and describe a particular network configuration.
.
.SH STRUCTURE
A
.B .neto
file yields a tree-structured description of a network. 
The tree is made up of \fBnode\fRs, \fBkey\fRs, and \fBvalue\fRs,
and \fBstring\fRs.
.
.TP
.B node
A
.B node
contains a list of
.BR key / value
pairs.
.TP
.B value
A 
.B value
can either be a
.B node
or a
.BR string .
.TP
.B key
A
.B key
is a string that provides the name for a particular
.BR value .
.BR key s
consist of a string of any printable character except whitespace,
'#' (which denotes a comment),
"!" (which is the separator for composite keys),
and "(" or ")" (which are used to mark
.B special
.BR keys ,
as described below).
.TP
.B string
A
.B string
is any string of printable characters.
.IP
A 
.B string
containing 
.BR <% " ... " %>
is treated as an ERB (Embedded Ruby) template,
and is fed through the ERB interpreter as the file is being read; the
value placed in the tree for such a string is the ERB interpreter's output,
not the ERB template itself.
.IP
(Note that parsing in general, and 
.B string
parsing in particular, is currently very simple-minded; for example, anything
from '#' to end-of-line is going to be ignored, as is leading and trailing
whitespace.  A future release will include a quoting mechanism to work around
these limitations.)
.
.SS Special Keys
.BR key s
may be
.B simple keys
(i.e., not containing a "!" separator), or
.B composite keys
(a series of simple keys separated by "!").
.PP
.B composite keys
that begin with a "!" are 
.B absolute keys
that are interpreted relative to the root of the current tree of nodes.
.B composite keys
that don't begin with a "!" are 
.B relative keys
that are interepreted relative to the current node in the tree.
.PP
.B simple keys
of the form
.BR ( " selector " )
are 
.B selector keys
which do various magic with the tree of nodes and keys.
The following 
.B selector keys
are available:
.TP
.B (<)
Maps to the
.B minimum
key of the node.  I.e., if the node has keys "a", "b", and "c", then
.B (<)
will map to "a".
.TP
.B (>)
Maps to the
.B maximum
key of the node.  I.e., if the node has keys "a", "b", and "c", then
.B (>)
will map to "c".
.TP
.B (+)
Maps to the
.B successor
key of the node, which is whatever would come next after the node's current
.B maximum
key.
I.e., if the node has keys "a", "b", and "c", then
.B (+)
will map to "d".
.TP
.B (..)
Maps to the 
.B parent
node of the current node (just like ".." as part of a UNIX file path).  So,
an absolute key of the form "!a!b!c!(..)" is the same as "!a!b"; if your tree
is set up such that "!a!b!c" is a valid path, and the current node is "!a!b!c", then 
.B (..)
relative to the current node will map to node "!a!b"
.TP
.B (...)
Maps to the
.B ancestor
of the current node having keys that match whatever follows to the right of
.BR (...) . 
For example, if you have a tree with nodes having keys:
.IP
.RS
.RS
!
.br
!a
.br
!a!b
.br
!a!b!c
.br
!a!b!c!d
.br
!a!b!c!d!e
.br
!a!b!c!x
.br
!a!b!c!x!y
.br
!a!b!c!x!y!z
.br
.RE
.RE
.IP
and you are at node !a!b!c!x!y!z, then
.B relative key
(...)!d!e
is going to refer to node !a!b!c (that being the closest ancestor
to !a!b!c!x!y!z that has sub-nodes !d!e)
.TP
.BI ( key = value[ , key = value,...] )
Maps to the child node of the current node having key/value pairs that match
all of the key/value pairs specified in the selector.  For example, if you have
a tree with nodes and keys like so:
.IP
.RS
.RS
! (node)
.br
!a (node)
.br
!a!b1 (node)
.br
!a!b1!k = "v1" (value)
.br
!a!b1!m = "x1" (value)
.br
!a!b2 (node)
.br
!a!b2!k = "v2" (value)
.br
!a!b2!m = "x2" (value)
.br
.RE
.RE
.IP
then "!a!(k=v1)" is going to map to node "!a!b1"
and "!a!(k=v2)" is going to map to node "!a!b2".
Similarly, "!a!(k=v1)!m" is going to map to the string "x1" (same as "!a!b1!m"),
and "!a!(k=v2)!m" is going to map to the string "x2" (same as "!a!b2!m").
.
.SS Special Strings
A 
.B string
containing 
.BR <% " ... " %>
is treated as an ERB (Embedded Ruby) template,
and is fed through the ERB interpreter as the file is being read; the
value placed in the tree for such a string is the ERB interpreter's output,
not the ERB template itself.
.
.SH FORMAT
A
.B .neto
file consists of a series of lines. 
Comments begin with a '#' symbol, and proceed to the end of the line.
Leading and trailing whitespace on a line are ignored, as are blank lines.
Once stripped of comments, leading whitespace, and trailing whitespace,
each line must match one of the following formats:
.TP
.IB key " = " string
Sets 
.I key
to be
.I string
in the current node.
.TP
.IB key " {"
.br
Creates a new (empty) sub-node of the current node,
names the new sub-node 
.IR key ,
and makes the new sub-node the current node (so that further lines
are processed relative to the sub-node, until the matching "\fB}\fR"
.TP
.IB key " < " source_key " {"
Creates a copy of the node identified by
.I source_key
as a new sub-node of the current node,
names the new sub-node 
.IR key ,
and makes the new sub-node the current node (so that further lines
are processed relative to the sub-node, until the matching "\fB}\fR"
.TP
.B }
.br
Ends processing of the current sub-node, and makes the current node
whatever it was before processing of the current sub-node began.
.TP
.BI .include " filename"
Incorporates a file in
.BR neto (5)
format into the tree at the current location, as if its contents appeared
here in the original file.
.TP
.BI .table " filename"
Incorporates a file in
.BR neto_table (5)
format into the tree at the current location.
.SH EXAMPLE
.nf
base_ip		= 10.5.0.0
admin_ip	= <%= ip_union(@target["(...)!base_ip"], "0.0.16.0") %>
syslog_ip	= <%= ip_union(@target["(...)!admin_ip"], "0.0.0.26") %>
syslog_facility = local5
snmp_ip		= <%= ip_union(@target["(...)!admin_ip"], "0.0.0.27") %>
snmp_community	= public
domain		= example.com

\&.table sample/vlans

\&.include sample/templates.neto

!templates!devices!(make=cisco,type=router) {
    # add to Cisco router device template
    model	= 4948-10G
    default_route = <%= ip_union(@target["(...)!base_ip"], "0.0.4.9") %>
    domain	= <%= "mgmt." + @target["(...)!domain"] %>
}

devices!(+) < !templates!devices!(make=cisco,type=router) {
    name	= switch-1
    role	= primary
    # can't put this in the template, because "name" isn't defined there
    ncg_output  = <%= "sample/configs/" + @target["name"] + ".config" %>
}

devices!(+) < !templates!devices!(make=cisco,type=router) {
    name	= switch-2
    role	= secondary
    # can't put this in the template, because "name" isn't defined there
    ncg_output  = <%= "sample/configs/" + @target["name"] + ".config" %>
}

\&.table sample/interfaces
.fi
.
.SH HISTORY
.P
.B ncg
was originally written in 2008 by Brent Chapman of Netomata, Inc.
.
.SH BUGS
.P
Probably.  Please report any you find by email to bugs@netomata.com.
.
.SH AUTHOR
Brent Chapman <brent@netomata.com> of Netomata, Inc.
.
.SH COPYRIGHT
Copyright (c) 2008 Netomata, Inc.
.PP
All Rights Reserved.
.
.SH "SEE ALSO"
ncg(1), ncg(5), neto_erb(5), neto_table(5).
